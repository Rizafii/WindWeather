<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/androidlead/weatherappui/data/repository/LocationRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/androidlead/weatherappui/data/repository/LocationRepository.kt" />
              <option name="originalContent" value="package androidlead.weatherappui.data.repository&#10;&#10;import android.content.Context&#10;import androidx.datastore.core.DataStore&#10;import androidx.datastore.preferences.core.Preferences&#10;import androidx.datastore.preferences.core.edit&#10;import androidx.datastore.preferences.core.stringPreferencesKey&#10;import androidx.datastore.preferences.preferencesDataStore&#10;import androidlead.weatherappui.data.model.SavedLocation&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.serialization.encodeToString&#10;import kotlinx.serialization.json.Json&#10;&#10;private val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = &quot;locations&quot;)&#10;&#10;class LocationRepository(private val context: Context) {&#10;    private val SAVED_LOCATIONS_KEY = stringPreferencesKey(&quot;saved_locations&quot;)&#10;    private val SELECTED_LOCATION_KEY = stringPreferencesKey(&quot;selected_location&quot;)&#10;&#10;    // Cache validity duration: 30 minutes&#10;    private val CACHE_VALIDITY_DURATION = 30 * 60 * 1000L // 30 minutes in milliseconds&#10;&#10;    private val json = Json {&#10;        ignoreUnknownKeys = true&#10;        encodeDefaults = true&#10;    }&#10;&#10;    fun getSavedLocations(): Flow&lt;List&lt;SavedLocation&gt;&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            val locationsJson = preferences[SAVED_LOCATIONS_KEY] ?: &quot;[]&quot;&#10;            try {&#10;                json.decodeFromString&lt;List&lt;SavedLocation&gt;&gt;(locationsJson)&#10;            } catch (e: Exception) {&#10;                emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getSelectedLocation(): Flow&lt;SavedLocation?&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            val locationJson = preferences[SELECTED_LOCATION_KEY]&#10;            locationJson?.let {&#10;                try {&#10;                    json.decodeFromString&lt;SavedLocation&gt;(it)&#10;                } catch (e: Exception) {&#10;                    null&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun saveLocation(location: SavedLocation) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            val currentLocations = getSavedLocationsSync(preferences)&#10;            val locationWithTimestamp = location.copy(lastUpdated = System.currentTimeMillis())&#10;            val updatedLocations = if (currentLocations.any { it.id == location.id }) {&#10;                currentLocations.map { if (it.id == location.id) locationWithTimestamp else it }&#10;            } else {&#10;                currentLocations + locationWithTimestamp&#10;            }&#10;            preferences[SAVED_LOCATIONS_KEY] = json.encodeToString(updatedLocations)&#10;        }&#10;    }&#10;&#10;    suspend fun updateLocationWeatherData(locationId: String, weatherData: SavedLocation) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            val currentLocations = getSavedLocationsSync(preferences)&#10;            val updatedLocations = currentLocations.map { location -&gt;&#10;                if (location.id == locationId) {&#10;                    weatherData.copy(&#10;                        id = location.id,&#10;                        name = location.name,&#10;                        country = location.country,&#10;                        state = location.state,&#10;                        latitude = location.latitude,&#10;                        longitude = location.longitude,&#10;                        isSelected = location.isSelected,&#10;                        isCurrentLocation = location.isCurrentLocation,&#10;                        lastUpdated = System.currentTimeMillis()&#10;                    )&#10;                } else {&#10;                    location&#10;                }&#10;            }&#10;            preferences[SAVED_LOCATIONS_KEY] = json.encodeToString(updatedLocations)&#10;        }&#10;    }&#10;&#10;    suspend fun deleteLocation(locationId: String) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            val currentLocations = getSavedLocationsSync(preferences)&#10;            val updatedLocations = currentLocations.filter { it.id != locationId }&#10;            preferences[SAVED_LOCATIONS_KEY] = json.encodeToString(updatedLocations)&#10;        }&#10;    }&#10;&#10;    suspend fun selectLocation(location: SavedLocation) {&#10;        context.dataStore.edit { preferences -&gt;&#10;            val locationWithTimestamp = location.copy(lastUpdated = System.currentTimeMillis())&#10;            preferences[SELECTED_LOCATION_KEY] = json.encodeToString(locationWithTimestamp)&#10;        }&#10;    }&#10;&#10;    // Check if location cache is still valid&#10;    fun isLocationCacheValid(location: SavedLocation): Boolean {&#10;        val currentTime = System.currentTimeMillis()&#10;        val cacheAge = currentTime - location.lastUpdated&#10;        return cacheAge &lt; CACHE_VALIDITY_DURATION&#10;    }&#10;&#10;    // Get location that needs weather update&#10;    suspend fun getLocationsNeedingUpdate(): List&lt;SavedLocation&gt; {&#10;        var result: List&lt;SavedLocation&gt; = emptyList()&#10;        context.dataStore.data.map { preferences -&gt;&#10;            val locations = getSavedLocationsSync(preferences)&#10;            result = locations.filter { !isLocationCacheValid(it) }&#10;        }&#10;        return result&#10;    }&#10;&#10;    private fun getSavedLocationsSync(preferences: Preferences): List&lt;SavedLocation&gt; {&#10;        val locationsJson = preferences[SAVED_LOCATIONS_KEY] ?: &quot;[]&quot;&#10;        return try {&#10;            json.decodeFromString&lt;List&lt;SavedLocation&gt;&gt;(locationsJson)&#10;        } catch (e: Exception) {&#10;            emptyList()&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package androidlead.weatherappui.data.repository&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import androidx.datastore.core.DataStore&#13;&#10;import androidx.datastore.preferences.core.Preferences&#13;&#10;import androidx.datastore.preferences.core.edit&#13;&#10;import androidx.datastore.preferences.core.stringPreferencesKey&#13;&#10;import androidx.datastore.preferences.preferencesDataStore&#13;&#10;import androidlead.weatherappui.data.model.SavedLocation&#13;&#10;import kotlinx.coroutines.flow.Flow&#13;&#10;import kotlinx.coroutines.flow.map&#13;&#10;import kotlinx.serialization.encodeToString&#13;&#10;import kotlinx.serialization.json.Json&#13;&#10;&#13;&#10;private val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = &quot;locations&quot;)&#13;&#10;&#13;&#10;class LocationRepository(private val context: Context) {&#13;&#10;    private val SAVED_LOCATIONS_KEY = stringPreferencesKey(&quot;saved_locations&quot;)&#13;&#10;    private val SELECTED_LOCATION_KEY = stringPreferencesKey(&quot;selected_location&quot;)&#13;&#10;&#13;&#10;    // Cache validity duration: 30 minutes&#13;&#10;    private val CACHE_VALIDITY_DURATION = 30 * 60 * 1000L // 30 minutes in milliseconds&#13;&#10;&#13;&#10;    private val json = Json {&#13;&#10;        ignoreUnknownKeys = true&#13;&#10;        encodeDefaults = true&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getSavedLocations(): Flow&lt;List&lt;SavedLocation&gt;&gt; {&#10;        return context.dataStore.data.map { preferences -&gt;&#10;            val locationsJson = preferences[SAVED_LOCATIONS_KEY] ?: &quot;[]&quot;&#10;            try {&#10;                val locations = json.decodeFromString&lt;List&lt;SavedLocation&gt;&gt;(locationsJson)&#10;                // Sort locations: GPS location (isCurrentLocation = true) first, then others&#10;                locations.sortedByDescending { it.isCurrentLocation }&#10;            } catch (e: Exception) {&#10;                emptyList()&#10;            }&#10;        }&#10;    }&#13;&#10;&#13;&#10;    fun getSelectedLocation(): Flow&lt;SavedLocation?&gt; {&#13;&#10;        return context.dataStore.data.map { preferences -&gt;&#13;&#10;            val locationJson = preferences[SELECTED_LOCATION_KEY]&#13;&#10;            locationJson?.let {&#13;&#10;                try {&#13;&#10;                    json.decodeFromString&lt;SavedLocation&gt;(it)&#13;&#10;                } catch (e: Exception) {&#13;&#10;                    null&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun saveLocation(location: SavedLocation) {&#13;&#10;        context.dataStore.edit { preferences -&gt;&#13;&#10;            val currentLocations = getSavedLocationsSync(preferences)&#13;&#10;            val locationWithTimestamp = location.copy(lastUpdated = System.currentTimeMillis())&#13;&#10;            val updatedLocations = if (currentLocations.any { it.id == location.id }) {&#13;&#10;                currentLocations.map { if (it.id == location.id) locationWithTimestamp else it }&#13;&#10;            } else {&#13;&#10;                currentLocations + locationWithTimestamp&#13;&#10;            }&#13;&#10;            preferences[SAVED_LOCATIONS_KEY] = json.encodeToString(updatedLocations)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun updateLocationWeatherData(locationId: String, weatherData: SavedLocation) {&#13;&#10;        context.dataStore.edit { preferences -&gt;&#13;&#10;            val currentLocations = getSavedLocationsSync(preferences)&#13;&#10;            val updatedLocations = currentLocations.map { location -&gt;&#13;&#10;                if (location.id == locationId) {&#13;&#10;                    weatherData.copy(&#13;&#10;                        id = location.id,&#13;&#10;                        name = location.name,&#13;&#10;                        country = location.country,&#13;&#10;                        state = location.state,&#13;&#10;                        latitude = location.latitude,&#13;&#10;                        longitude = location.longitude,&#13;&#10;                        isSelected = location.isSelected,&#13;&#10;                        isCurrentLocation = location.isCurrentLocation,&#13;&#10;                        lastUpdated = System.currentTimeMillis()&#13;&#10;                    )&#13;&#10;                } else {&#13;&#10;                    location&#13;&#10;                }&#13;&#10;            }&#13;&#10;            preferences[SAVED_LOCATIONS_KEY] = json.encodeToString(updatedLocations)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun deleteLocation(locationId: String) {&#13;&#10;        context.dataStore.edit { preferences -&gt;&#13;&#10;            val currentLocations = getSavedLocationsSync(preferences)&#13;&#10;            val updatedLocations = currentLocations.filter { it.id != locationId }&#13;&#10;            preferences[SAVED_LOCATIONS_KEY] = json.encodeToString(updatedLocations)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun selectLocation(location: SavedLocation) {&#13;&#10;        context.dataStore.edit { preferences -&gt;&#13;&#10;            val locationWithTimestamp = location.copy(lastUpdated = System.currentTimeMillis())&#13;&#10;            preferences[SELECTED_LOCATION_KEY] = json.encodeToString(locationWithTimestamp)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Check if location cache is still valid&#13;&#10;    fun isLocationCacheValid(location: SavedLocation): Boolean {&#13;&#10;        val currentTime = System.currentTimeMillis()&#13;&#10;        val cacheAge = currentTime - location.lastUpdated&#13;&#10;        return cacheAge &lt; CACHE_VALIDITY_DURATION&#13;&#10;    }&#13;&#10;&#13;&#10;    // Get location that needs weather update&#13;&#10;    suspend fun getLocationsNeedingUpdate(): List&lt;SavedLocation&gt; {&#13;&#10;        var result: List&lt;SavedLocation&gt; = emptyList()&#13;&#10;        context.dataStore.data.map { preferences -&gt;&#13;&#10;            val locations = getSavedLocationsSync(preferences)&#13;&#10;            result = locations.filter { !isLocationCacheValid(it) }&#13;&#10;        }&#13;&#10;        return result&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun getSavedLocationsSync(preferences: Preferences): List&lt;SavedLocation&gt; {&#13;&#10;        val locationsJson = preferences[SAVED_LOCATIONS_KEY] ?: &quot;[]&quot;&#13;&#10;        return try {&#13;&#10;            json.decodeFromString&lt;List&lt;SavedLocation&gt;&gt;(locationsJson)&#13;&#10;        } catch (e: Exception) {&#13;&#10;            emptyList()&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/androidlead/weatherappui/ui/screen/locations/LocationsViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/androidlead/weatherappui/ui/screen/locations/LocationsViewModel.kt" />
              <option name="originalContent" value="package androidlead.weatherappui.ui.screen.locations&#10;&#10;import android.content.Context&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import androidlead.weatherappui.data.model.SavedLocation&#10;import androidlead.weatherappui.data.repository.GeocodingRepository&#10;import androidlead.weatherappui.data.repository.LocationRepository&#10;import androidlead.weatherappui.data.repository.WeatherRepository&#10;import androidlead.weatherappui.service.LocationService&#10;import androidlead.weatherappui.util.WeatherCodeMapper&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import java.util.UUID&#10;&#10;data class LocationsUiState(&#10;    val savedLocations: List&lt;SavedLocation&gt; = emptyList(),&#10;    val searchQuery: String = &quot;&quot;,&#10;    val searchResults: List&lt;SavedLocation&gt; = emptyList(),&#10;    val isSearching: Boolean = false,&#10;    val showAddDialog: Boolean = false,&#10;    val isLoading: Boolean = false&#10;)&#10;&#10;class LocationsViewModel(&#10;    private val repository: LocationRepository,&#10;    private val context: Context&#10;) : ViewModel() {&#10;&#10;    private val weatherRepository = WeatherRepository()&#10;    private val geocodingRepository = GeocodingRepository()&#10;    private val locationService = LocationService(context)&#10;&#10;    private val _uiState = MutableStateFlow(LocationsUiState())&#10;    val uiState: StateFlow&lt;LocationsUiState&gt; = _uiState.asStateFlow()&#10;&#10;    private var searchJob: Job? = null&#10;&#10;    companion object {&#10;        private const val SEARCH_DELAY = 500L // milliseconds&#10;    }&#10;&#10;    init {&#10;        loadSavedLocations()&#10;    }&#10;&#10;    private fun loadSavedLocations() {&#10;        viewModelScope.launch {&#10;            repository.getSavedLocations().collect { locations -&gt;&#10;                // First, show cached data immediately (loadless)&#10;                _uiState.value = _uiState.value.copy(savedLocations = locations)&#10;&#10;                // Then, update only stale locations in the background&#10;                val staleLocations = locations.filter { !repository.isLocationCacheValid(it) }&#10;                if (staleLocations.isNotEmpty()) {&#10;                    updateStaleLocations(staleLocations)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun updateStaleLocations(staleLocations: List&lt;SavedLocation&gt;) {&#10;        staleLocations.forEach { location -&gt;&#10;            val updatedLocation = updateLocationWeather(location)&#10;            repository.updateLocationWeatherData(location.id, updatedLocation)&#10;        }&#10;    }&#10;&#10;    private suspend fun updateLocationWeather(location: SavedLocation): SavedLocation {&#10;        return try {&#10;            val result = weatherRepository.getWeather(location.latitude, location.longitude)&#10;            result.fold(&#10;                onSuccess = { weatherResponse -&gt;&#10;                    location.copy(&#10;                        temperature = weatherResponse.current.temperature,&#10;                        weatherCondition = WeatherCodeMapper.getWeatherDescription(context, weatherResponse.current.weatherCode),&#10;                        weatherIcon = WeatherCodeMapper.getWeatherIcon(weatherResponse.current.weatherCode).toString(),&#10;                        humidity = weatherResponse.current.humidity,&#10;                        windSpeed = weatherResponse.current.windSpeed,&#10;                        apparentTemperature = weatherResponse.current.apparentTemperature,&#10;                        weatherCode = weatherResponse.current.weatherCode,&#10;                        lastUpdated = System.currentTimeMillis()&#10;                    )&#10;                },&#10;                onFailure = {&#10;                    location // Return location as is if failed&#10;                }&#10;            )&#10;        } catch (_: Exception) {&#10;            location // Return location as is if exception&#10;        }&#10;    }&#10;&#10;    fun onSearchQueryChange(query: String) {&#10;        _uiState.value = _uiState.value.copy(searchQuery = query)&#10;&#10;        // Cancel previous search job&#10;        searchJob?.cancel()&#10;&#10;        if (query.length &gt;= 2) {&#10;            // Start new search job with delay (debounce)&#10;            searchJob = viewModelScope.launch {&#10;                delay(SEARCH_DELAY)&#10;                searchLocations(query)&#10;            }&#10;        } else {&#10;            _uiState.value = _uiState.value.copy(searchResults = emptyList())&#10;        }&#10;    }&#10;&#10;    private fun searchLocations(query: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isSearching = true)&#10;&#10;            // Gunakan Geocoding API untuk search lokasi&#10;            val result = geocodingRepository.searchLocations(query)&#10;&#10;            result.fold(&#10;                onSuccess = { geocodingResults -&gt;&#10;                    // Convert geocoding results to SavedLocation&#10;                    val locations = geocodingResults.map { result -&gt;&#10;                        SavedLocation(&#10;                            id = UUID.randomUUID().toString(),&#10;                            name = result.name,&#10;                            country = result.country ?: &quot;&quot;,&#10;                            state = result.admin1 ?: &quot;&quot;, // Add state/province&#10;                            latitude = result.latitude,&#10;                            longitude = result.longitude&#10;                        )&#10;                    }&#10;&#10;                    // Fetch weather data untuk setiap hasil&#10;                    val locationsWithWeather = locations.map { location -&gt;&#10;                        updateLocationWeather(location)&#10;                    }&#10;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        searchResults = locationsWithWeather,&#10;                        isSearching = false&#10;                    )&#10;                },&#10;                onFailure = {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        searchResults = emptyList(),&#10;                        isSearching = false&#10;                    )&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    fun addLocation(location: SavedLocation) {&#10;        viewModelScope.launch {&#10;            repository.saveLocation(location)&#10;            _uiState.value = _uiState.value.copy(&#10;                showAddDialog = false,&#10;                searchQuery = &quot;&quot;,&#10;                searchResults = emptyList()&#10;            )&#10;        }&#10;    }&#10;&#10;    fun deleteLocation(locationId: String) {&#10;        viewModelScope.launch {&#10;            repository.deleteLocation(locationId)&#10;        }&#10;    }&#10;&#10;    fun selectLocation(location: SavedLocation) {&#10;        viewModelScope.launch {&#10;            repository.selectLocation(location)&#10;        }&#10;    }&#10;&#10;    fun refreshWeatherData() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            val currentLocations = _uiState.value.savedLocations&#10;            val updatedLocations = currentLocations.map { location -&gt;&#10;                val updated = updateLocationWeather(location)&#10;                // Save updated data to cache&#10;                repository.updateLocationWeatherData(location.id, updated)&#10;                updated&#10;            }&#10;&#10;            _uiState.value = _uiState.value.copy(&#10;                savedLocations = updatedLocations,&#10;                isLoading = false&#10;            )&#10;        }&#10;    }&#10;&#10;    fun showAddDialog() {&#10;        _uiState.value = _uiState.value.copy(showAddDialog = true)&#10;    }&#10;&#10;    fun hideAddDialog() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showAddDialog = false,&#10;            searchQuery = &quot;&quot;,&#10;            searchResults = emptyList()&#10;        )&#10;    }&#10;&#10;    // Fungsi untuk add current location dari GPS&#10;    fun addCurrentLocation() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            val locationCoords = locationService.getCurrentLocation()&#10;&#10;            if (locationCoords != null) {&#10;                val (lat, lon) = locationCoords&#10;                val cityName = locationService.getCityName(lat, lon)&#10;&#10;                // Buat SavedLocation dengan flag isCurrentLocation&#10;                val currentLocation = SavedLocation(&#10;                    id = &quot;current_location&quot;,&#10;                    name = cityName,&#10;                    country = &quot;My Location&quot;,&#10;                    latitude = lat,&#10;                    longitude = lon,&#10;                    isCurrentLocation = true&#10;                )&#10;&#10;                // Fetch weather data&#10;                val locationWithWeather = updateLocationWeather(currentLocation)&#10;&#10;                // Save ke repository&#10;                repository.saveLocation(locationWithWeather)&#10;            }&#10;&#10;            _uiState.value = _uiState.value.copy(isLoading = false)&#10;        }&#10;    }&#10;&#10;    fun hasLocationPermission(): Boolean {&#10;        return locationService.hasLocationPermission()&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package androidlead.weatherappui.ui.screen.locations&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import androidlead.weatherappui.data.model.SavedLocation&#13;&#10;import androidlead.weatherappui.data.repository.GeocodingRepository&#13;&#10;import androidlead.weatherappui.data.repository.LocationRepository&#13;&#10;import androidlead.weatherappui.data.repository.WeatherRepository&#13;&#10;import androidlead.weatherappui.service.LocationService&#13;&#10;import androidlead.weatherappui.util.WeatherCodeMapper&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import kotlinx.coroutines.Job&#13;&#10;import kotlinx.coroutines.delay&#13;&#10;import java.util.UUID&#13;&#10;&#13;&#10;data class LocationsUiState(&#13;&#10;    val savedLocations: List&lt;SavedLocation&gt; = emptyList(),&#13;&#10;    val searchQuery: String = &quot;&quot;,&#13;&#10;    val searchResults: List&lt;SavedLocation&gt; = emptyList(),&#13;&#10;    val isSearching: Boolean = false,&#13;&#10;    val showAddDialog: Boolean = false,&#13;&#10;    val isLoading: Boolean = false&#13;&#10;)&#13;&#10;&#13;&#10;class LocationsViewModel(&#13;&#10;    private val repository: LocationRepository,&#13;&#10;    private val context: Context&#13;&#10;) : ViewModel() {&#13;&#10;&#13;&#10;    private val weatherRepository = WeatherRepository()&#13;&#10;    private val geocodingRepository = GeocodingRepository()&#13;&#10;    private val locationService = LocationService(context)&#13;&#10;&#13;&#10;    private val _uiState = MutableStateFlow(LocationsUiState())&#13;&#10;    val uiState: StateFlow&lt;LocationsUiState&gt; = _uiState.asStateFlow()&#13;&#10;&#13;&#10;    private var searchJob: Job? = null&#13;&#10;&#13;&#10;    companion object {&#13;&#10;        private const val SEARCH_DELAY = 500L // milliseconds&#13;&#10;    }&#13;&#10;&#13;&#10;    init {&#10;        loadSavedLocations()&#10;    }&#10;&#10;    private fun loadSavedLocations() {&#10;        viewModelScope.launch {&#10;            repository.getSavedLocations().collect { locations -&gt;&#10;                // First, show cached data immediately (loadless)&#10;                _uiState.value = _uiState.value.copy(savedLocations = locations)&#10;&#10;                // Check if this is the first launch (no saved locations)&#10;                if (locations.isEmpty() &amp;&amp; hasLocationPermission()) {&#10;                    // Automatically add GPS location on first launch&#10;                    addCurrentLocationOnFirstLaunch()&#10;                } else {&#10;                    // Then, update only stale locations in the background&#10;                    val staleLocations = locations.filter { !repository.isLocationCacheValid(it) }&#10;                    if (staleLocations.isNotEmpty()) {&#10;                        updateStaleLocations(staleLocations)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun addCurrentLocationOnFirstLaunch() {&#10;        _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;        val locationCoords = locationService.getCurrentLocation()&#10;&#10;        if (locationCoords != null) {&#10;            val (lat, lon) = locationCoords&#10;            val cityName = locationService.getCityName(lat, lon)&#10;&#10;            // Buat SavedLocation dengan flag isCurrentLocation&#10;            val currentLocation = SavedLocation(&#10;                id = &quot;current_location&quot;,&#10;                name = cityName,&#10;                country = &quot;My Location&quot;,&#10;                latitude = lat,&#10;                longitude = lon,&#10;                isCurrentLocation = true&#10;            )&#10;&#10;            // Fetch weather data&#10;            val locationWithWeather = updateLocationWeather(currentLocation)&#10;&#10;            // Save ke repository&#10;            repository.saveLocation(locationWithWeather)&#10;        }&#10;&#10;        _uiState.value = _uiState.value.copy(isLoading = false)&#10;    }&#13;&#10;&#13;&#10;    private suspend fun updateStaleLocations(staleLocations: List&lt;SavedLocation&gt;) {&#13;&#10;        staleLocations.forEach { location -&gt;&#13;&#10;            val updatedLocation = updateLocationWeather(location)&#13;&#10;            repository.updateLocationWeatherData(location.id, updatedLocation)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private suspend fun updateLocationWeather(location: SavedLocation): SavedLocation {&#13;&#10;        return try {&#13;&#10;            val result = weatherRepository.getWeather(location.latitude, location.longitude)&#13;&#10;            result.fold(&#13;&#10;                onSuccess = { weatherResponse -&gt;&#13;&#10;                    location.copy(&#13;&#10;                        temperature = weatherResponse.current.temperature,&#13;&#10;                        weatherCondition = WeatherCodeMapper.getWeatherDescription(context, weatherResponse.current.weatherCode),&#13;&#10;                        weatherIcon = WeatherCodeMapper.getWeatherIcon(weatherResponse.current.weatherCode).toString(),&#13;&#10;                        humidity = weatherResponse.current.humidity,&#13;&#10;                        windSpeed = weatherResponse.current.windSpeed,&#13;&#10;                        apparentTemperature = weatherResponse.current.apparentTemperature,&#13;&#10;                        weatherCode = weatherResponse.current.weatherCode,&#13;&#10;                        lastUpdated = System.currentTimeMillis()&#13;&#10;                    )&#13;&#10;                },&#13;&#10;                onFailure = {&#13;&#10;                    location // Return location as is if failed&#13;&#10;                }&#13;&#10;            )&#13;&#10;        } catch (_: Exception) {&#13;&#10;            location // Return location as is if exception&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun onSearchQueryChange(query: String) {&#13;&#10;        _uiState.value = _uiState.value.copy(searchQuery = query)&#13;&#10;&#13;&#10;        // Cancel previous search job&#13;&#10;        searchJob?.cancel()&#13;&#10;&#13;&#10;        if (query.length &gt;= 2) {&#13;&#10;            // Start new search job with delay (debounce)&#13;&#10;            searchJob = viewModelScope.launch {&#13;&#10;                delay(SEARCH_DELAY)&#13;&#10;                searchLocations(query)&#13;&#10;            }&#13;&#10;        } else {&#13;&#10;            _uiState.value = _uiState.value.copy(searchResults = emptyList())&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun searchLocations(query: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _uiState.value = _uiState.value.copy(isSearching = true)&#13;&#10;&#13;&#10;            // Gunakan Geocoding API untuk search lokasi&#13;&#10;            val result = geocodingRepository.searchLocations(query)&#13;&#10;&#13;&#10;            result.fold(&#13;&#10;                onSuccess = { geocodingResults -&gt;&#13;&#10;                    // Convert geocoding results to SavedLocation&#13;&#10;                    val locations = geocodingResults.map { result -&gt;&#13;&#10;                        SavedLocation(&#13;&#10;                            id = UUID.randomUUID().toString(),&#13;&#10;                            name = result.name,&#13;&#10;                            country = result.country ?: &quot;&quot;,&#13;&#10;                            state = result.admin1 ?: &quot;&quot;, // Add state/province&#13;&#10;                            latitude = result.latitude,&#13;&#10;                            longitude = result.longitude&#13;&#10;                        )&#13;&#10;                    }&#13;&#10;&#13;&#10;                    // Fetch weather data untuk setiap hasil&#13;&#10;                    val locationsWithWeather = locations.map { location -&gt;&#13;&#10;                        updateLocationWeather(location)&#13;&#10;                    }&#13;&#10;&#13;&#10;                    _uiState.value = _uiState.value.copy(&#13;&#10;                        searchResults = locationsWithWeather,&#13;&#10;                        isSearching = false&#13;&#10;                    )&#13;&#10;                },&#13;&#10;                onFailure = {&#13;&#10;                    _uiState.value = _uiState.value.copy(&#13;&#10;                        searchResults = emptyList(),&#13;&#10;                        isSearching = false&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun addLocation(location: SavedLocation) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            repository.saveLocation(location)&#13;&#10;            _uiState.value = _uiState.value.copy(&#13;&#10;                showAddDialog = false,&#13;&#10;                searchQuery = &quot;&quot;,&#13;&#10;                searchResults = emptyList()&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun deleteLocation(locationId: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            repository.deleteLocation(locationId)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun selectLocation(location: SavedLocation) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            repository.selectLocation(location)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun refreshWeatherData() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#13;&#10;&#13;&#10;            val currentLocations = _uiState.value.savedLocations&#13;&#10;            val updatedLocations = currentLocations.map { location -&gt;&#13;&#10;                val updated = updateLocationWeather(location)&#13;&#10;                // Save updated data to cache&#13;&#10;                repository.updateLocationWeatherData(location.id, updated)&#13;&#10;                updated&#13;&#10;            }&#13;&#10;&#13;&#10;            _uiState.value = _uiState.value.copy(&#13;&#10;                savedLocations = updatedLocations,&#13;&#10;                isLoading = false&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun showAddDialog() {&#13;&#10;        _uiState.value = _uiState.value.copy(showAddDialog = true)&#13;&#10;    }&#13;&#10;&#13;&#10;    fun hideAddDialog() {&#13;&#10;        _uiState.value = _uiState.value.copy(&#13;&#10;            showAddDialog = false,&#13;&#10;            searchQuery = &quot;&quot;,&#13;&#10;            searchResults = emptyList()&#13;&#10;        )&#13;&#10;    }&#13;&#10;&#13;&#10;    // Fungsi untuk add current location dari GPS&#13;&#10;    fun addCurrentLocation() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#13;&#10;&#13;&#10;            val locationCoords = locationService.getCurrentLocation()&#13;&#10;&#13;&#10;            if (locationCoords != null) {&#13;&#10;                val (lat, lon) = locationCoords&#13;&#10;                val cityName = locationService.getCityName(lat, lon)&#13;&#10;&#13;&#10;                // Buat SavedLocation dengan flag isCurrentLocation&#13;&#10;                val currentLocation = SavedLocation(&#13;&#10;                    id = &quot;current_location&quot;,&#13;&#10;                    name = cityName,&#13;&#10;                    country = &quot;My Location&quot;,&#13;&#10;                    latitude = lat,&#13;&#10;                    longitude = lon,&#13;&#10;                    isCurrentLocation = true&#13;&#10;                )&#13;&#10;&#13;&#10;                // Fetch weather data&#13;&#10;                val locationWithWeather = updateLocationWeather(currentLocation)&#13;&#10;&#13;&#10;                // Save ke repository&#13;&#10;                repository.saveLocation(locationWithWeather)&#13;&#10;            }&#13;&#10;&#13;&#10;            _uiState.value = _uiState.value.copy(isLoading = false)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun hasLocationPermission(): Boolean {&#13;&#10;        return locationService.hasLocationPermission()&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/androidlead/weatherappui/viewmodel/WeatherViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/androidlead/weatherappui/viewmodel/WeatherViewModel.kt" />
              <option name="originalContent" value="package androidlead.weatherappui.viewmodel&#10;&#10;import android.content.Context&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import androidlead.weatherappui.R&#10;import androidlead.weatherappui.data.model.Location&#10;import androidlead.weatherappui.data.model.SavedLocation&#10;import androidlead.weatherappui.data.model.WeatherResponse&#10;import androidlead.weatherappui.data.repository.LocationRepository&#10;import androidlead.weatherappui.data.repository.WeatherRepository&#10;import androidlead.weatherappui.service.LocationService&#10;import androidlead.weatherappui.ui.screen.util.AirQualityItem&#10;import androidlead.weatherappui.ui.screen.util.ForecastItem&#10;import androidlead.weatherappui.ui.screen.util.HourlyForecastItem&#10;import androidlead.weatherappui.ui.screen.util.WeatherTipItem&#10;import androidlead.weatherappui.util.WeatherCodeMapper&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.Calendar&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;data class WeatherUiState(&#10;    val isLoading: Boolean = false,&#10;    val currentLocation: Location? = null,&#10;    val savedLocations: List&lt;Location&gt; = emptyList(),&#10;    val weatherData: WeatherResponse? = null,&#10;    val forecastItems: List&lt;ForecastItem&gt; = emptyList(),&#10;    val hourlyForecastItems: List&lt;HourlyForecastItem&gt; = emptyList(),&#10;    val airQualityItems: List&lt;AirQualityItem&gt; = emptyList(),&#10;    val weatherTips: List&lt;WeatherTipItem&gt; = emptyList(),&#10;    val currentTemperature: String = &quot;21&quot;,&#10;    val currentDescription: String = &quot;Rain showers&quot;,&#10;    val currentDate: String = &quot;Monday, 12 Feb&quot;,&#10;    val feelsLike: String = &quot;Feels like 26째&quot;,&#10;    val currentWeatherIcon: Int = R.drawable.img_sub_rain,&#10;    val currentWeatherVideo: Int = R.raw.video_rain,&#10;    val error: String? = null,&#10;    val hasLocationPermission: Boolean = false,&#10;    val selectedDayIndex: Int = 0&#10;)&#10;&#10;class WeatherViewModel(private val context: Context) : ViewModel() {&#10;&#10;    private val repository = WeatherRepository()&#10;    private val locationRepository = LocationRepository(context)&#10;    private val locationService = LocationService(context)&#10;&#10;    private val _uiState = MutableStateFlow(WeatherUiState())&#10;    val uiState: StateFlow&lt;WeatherUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Default locations&#10;    private val defaultLocations = listOf(&#10;        Location(&quot;Rome&quot;, 41.9028, 12.4964),&#10;        Location(&quot;New York&quot;, 40.7128, -74.0060),&#10;        Location(&quot;Tokyo&quot;, 35.6762, 139.6503),&#10;        Location(&quot;London&quot;, 51.5074, -0.1278),&#10;        Location(&quot;Paris&quot;, 48.8566, 2.3522)&#10;    )&#10;&#10;    init {&#10;        _uiState.value = _uiState.value.copy(&#10;            savedLocations = defaultLocations,&#10;            hasLocationPermission = locationService.hasLocationPermission()&#10;        )&#10;        // Load from cache first, then fetch if needed&#10;        loadFromCacheOrFetch()&#10;    }&#10;&#10;    private fun loadFromCacheOrFetch() {&#10;        viewModelScope.launch {&#10;            // Try to load selected location from cache&#10;            val cachedLocation = locationRepository.getSelectedLocation().first()&#10;&#10;            if (cachedLocation != null &amp;&amp; locationRepository.isLocationCacheValid(cachedLocation)) {&#10;                // Use cached data (loadless)&#10;                loadFromCachedLocation(cachedLocation)&#10;            } else if (cachedLocation != null) {&#10;                // Show cached data first, then refresh&#10;                loadFromCachedLocation(cachedLocation)&#10;                loadWeather(cachedLocation.latitude, cachedLocation.longitude, cachedLocation.name)&#10;            } else {&#10;                // No cache, load default location&#10;                loadWeatherForLocation(defaultLocations[0])&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadFromCachedLocation(location: SavedLocation) {&#10;        val calendar = Calendar.getInstance()&#10;        val formattedDate = SimpleDateFormat(&quot;EEEE, dd MMM&quot;, Locale.getDefault()).format(calendar.time)&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            isLoading = false,&#10;            currentLocation = Location(location.name, location.latitude, location.longitude),&#10;            currentTemperature = location.temperature.toInt().toString(),&#10;            currentDescription = location.weatherCondition,&#10;            currentDate = formattedDate,&#10;            feelsLike = context.getString(R.string.feels_like) + &quot; ${location.apparentTemperature.toInt()}째&quot;,&#10;            currentWeatherIcon = WeatherCodeMapper.getWeatherIcon(location.weatherCode),&#10;            currentWeatherVideo = WeatherCodeMapper.getWeatherVideo(location.weatherCode)&#10;        )&#10;    }&#10;&#10;    fun checkAndRequestLocation() {&#10;        if (locationService.hasLocationPermission()) {&#10;            _uiState.value = _uiState.value.copy(hasLocationPermission = true)&#10;            loadCurrentLocationWeather()&#10;        } else {&#10;            _uiState.value = _uiState.value.copy(hasLocationPermission = false)&#10;        }&#10;    }&#10;&#10;    fun loadCurrentLocationWeather() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;            val locationCoords = locationService.getCurrentLocation()&#10;            if (locationCoords != null) {&#10;                val (lat, lon) = locationCoords&#10;                val cityName = locationService.getCityName(lat, lon)&#10;                val currentLocation = Location(cityName, lat, lon, isCurrentLocation = true)&#10;&#10;                _uiState.value = _uiState.value.copy(currentLocation = currentLocation)&#10;                loadWeather(lat, lon, cityName)&#10;            } else {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    error = &quot;Failed to get current location&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadWeatherForLocation(location: Location) {&#10;        loadWeather(location.latitude, location.longitude, location.name)&#10;    }&#10;&#10;    fun fetchWeatherByCoordinates(latitude: Double, longitude: Double, locationName: String) {&#10;        loadWeather(latitude, longitude, locationName)&#10;    }&#10;&#10;    private fun loadWeather(latitude: Double, longitude: Double, locationName: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;            val result = repository.getWeather(latitude, longitude)&#10;&#10;            result.onSuccess { weatherResponse -&gt;&#10;                val forecastItems = mapToForecastItems(weatherResponse)&#10;                val airQualityItems = mapToAirQualityItems(weatherResponse)&#10;                val hourlyForecastItems = mapToHourlyForecastItems(weatherResponse)&#10;&#10;                // Get current date formatted&#10;                val calendar = Calendar.getInstance()&#10;                val formattedDate = SimpleDateFormat(&quot;EEEE, dd MMM&quot;, Locale.getDefault()).format(calendar.time)&#10;&#10;                // Generate weather tips&#10;                val weatherTips = WeatherCodeMapper.getWeatherTips(&#10;                    context = context,&#10;                    weatherCode = weatherResponse.current.weatherCode,&#10;                    temperature = weatherResponse.current.temperature.toInt(),&#10;                    uvIndex = weatherResponse.daily.uvIndexMax.firstOrNull()?.toInt() ?: 0,&#10;                    humidity = weatherResponse.current.humidity&#10;                )&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    weatherData = weatherResponse,&#10;                    forecastItems = forecastItems,&#10;                    hourlyForecastItems = hourlyForecastItems,&#10;                    airQualityItems = airQualityItems,&#10;                    weatherTips = weatherTips,&#10;                    currentTemperature = weatherResponse.current.temperature.toInt().toString(),&#10;                    currentDescription = WeatherCodeMapper.getWeatherDescription(context, weatherResponse.current.weatherCode),&#10;                    currentDate = formattedDate,&#10;                    feelsLike = context.getString(R.string.feels_like) + &quot; ${weatherResponse.current.apparentTemperature.toInt()}째&quot;,&#10;                    currentWeatherIcon = WeatherCodeMapper.getWeatherIcon(weatherResponse.current.weatherCode),&#10;                    currentWeatherVideo = WeatherCodeMapper.getWeatherVideo(weatherResponse.current.weatherCode),&#10;                    currentLocation = _uiState.value.currentLocation?.copy(name = locationName)&#10;                        ?: Location(locationName, latitude, longitude)&#10;                )&#10;&#10;                // Save to cache for loadless experience next time&#10;                val cachedLocation = SavedLocation(&#10;                    id = &quot;selected_location&quot;,&#10;                    name = locationName,&#10;                    latitude = latitude,&#10;                    longitude = longitude,&#10;                    temperature = weatherResponse.current.temperature,&#10;                    weatherCondition = WeatherCodeMapper.getWeatherDescription(context, weatherResponse.current.weatherCode),&#10;                    weatherIcon = WeatherCodeMapper.getWeatherIcon(weatherResponse.current.weatherCode).toString(),&#10;                    humidity = weatherResponse.current.humidity,&#10;                    windSpeed = weatherResponse.current.windSpeed,&#10;                    apparentTemperature = weatherResponse.current.apparentTemperature,&#10;                    weatherCode = weatherResponse.current.weatherCode,&#10;                    lastUpdated = System.currentTimeMillis()&#10;                )&#10;                locationRepository.selectLocation(cachedLocation)&#10;            }.onFailure { exception -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    error = exception.message ?: &quot;Failed to load weather data&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapToForecastItems(weatherResponse: WeatherResponse): List&lt;ForecastItem&gt; {&#10;        val dailyData = weatherResponse.daily&#10;        val selectedIndex = _uiState.value.selectedDayIndex&#10;        return dailyData.time.mapIndexed { index, date -&gt;&#10;            val calendar = Calendar.getInstance()&#10;            val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;            calendar.time = dateFormat.parse(date) ?: Date()&#10;&#10;            val dayOfWeek = SimpleDateFormat(&quot;EEE&quot;, Locale.getDefault()).format(calendar.time)&#10;            val dateStr = SimpleDateFormat(&quot;dd MMM&quot;, Locale.getDefault()).format(calendar.time)&#10;&#10;            val weatherCode = dailyData.weatherCode[index]&#10;            val maxTemp = dailyData.temperatureMax[index].toInt()&#10;            val uvIndex = dailyData.uvIndexMax.getOrNull(index)?.toInt() ?: 0&#10;&#10;            ForecastItem(&#10;                image = WeatherCodeMapper.getWeatherIcon(weatherCode),&#10;                dayOfWeek = dayOfWeek,&#10;                date = dateStr,&#10;                temperature = &quot;$maxTemp째&quot;,&#10;                airQuality = uvIndex.toString(),&#10;                airQualityIndicatorColorHex = getAirQualityColor(uvIndex),&#10;                isSelected = index == selectedIndex&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun mapToAirQualityItems(weatherResponse: WeatherResponse, dayIndex: Int = 0): List&lt;AirQualityItem&gt; {&#10;        val dailyData = weatherResponse.daily&#10;        val hourlyData = weatherResponse.hourly&#10;        val current = weatherResponse.current&#10;&#10;        // Get data for selected day&#10;        val targetDate = if (dayIndex &lt; dailyData.time.size) {&#10;            dailyData.time[dayIndex]&#10;        } else {&#10;            dailyData.time[0]&#10;        }&#10;&#10;        // Calculate average temperature and humidity from hourly data for the selected day&#10;        var avgTemp = 0.0&#10;        var avgHumidity = 0&#10;        var count = 0&#10;&#10;        hourlyData.time.forEachIndexed { index, timeString -&gt;&#10;            if (timeString.startsWith(targetDate)) {&#10;                avgTemp += hourlyData.temperature[index]&#10;                avgHumidity += hourlyData.humidity[index]&#10;                count++&#10;            }&#10;        }&#10;&#10;        if (count &gt; 0) {&#10;            avgTemp /= count&#10;            avgHumidity /= count&#10;        } else {&#10;            // Fallback to using min/max temp average&#10;            avgTemp = (dailyData.temperatureMax[dayIndex] + dailyData.temperatureMin[dayIndex]) / 2&#10;            avgHumidity = current.humidity&#10;        }&#10;&#10;        // Get UV Index for the selected day&#10;        val uvIndex = dailyData.uvIndexMax.getOrNull(dayIndex)?.toInt() ?: 0&#10;&#10;        return listOf(&#10;            AirQualityItem(&#10;                title = context.getString(R.string.real_feel),&#10;                value = &quot;${avgTemp.toInt()}째&quot;,&#10;                icon = R.drawable.ic_real_feel&#10;            ),&#10;            AirQualityItem(&#10;                title = context.getString(R.string.wind),&#10;                value = &quot;${current.windSpeed.toInt()}${context.getString(R.string.kmh)}&quot;,&#10;                icon = R.drawable.ic_wind_qality&#10;            ),&#10;            AirQualityItem(&#10;                title = context.getString(R.string.humidity),&#10;                value = &quot;$avgHumidity${context.getString(R.string.percent)}&quot;,&#10;                icon = R.drawable.ic_so2&#10;            ),&#10;            AirQualityItem(&#10;                title = context.getString(R.string.rain),&#10;                value = &quot;0${context.getString(R.string.percent)}&quot;,&#10;                icon = R.drawable.ic_rain_chance&#10;            ),&#10;            AirQualityItem(&#10;                title = context.getString(R.string.uv_index),&#10;                value = uvIndex.toString(),&#10;                icon = R.drawable.ic_uv_index&#10;            ),&#10;            AirQualityItem(&#10;                title = context.getString(R.string.wind_dir),&#10;                value = &quot;${current.windDirection}째&quot;,&#10;                icon = R.drawable.ic_o3&#10;            )&#10;        )&#10;    }&#10;&#10;    private fun mapToHourlyForecastItems(weatherResponse: WeatherResponse, dayIndex: Int = 0): List&lt;HourlyForecastItem&gt; {&#10;        val hourlyData = weatherResponse.hourly&#10;        val dailyData = weatherResponse.daily&#10;&#10;        // Get the target date&#10;        val targetDate = if (dayIndex &lt; dailyData.time.size) {&#10;            dailyData.time[dayIndex]&#10;        } else {&#10;            dailyData.time[0]&#10;        }&#10;&#10;        // Filter hourly data for the selected day and get up to 24 hours&#10;        val filteredHours = mutableListOf&lt;HourlyForecastItem&gt;()&#10;&#10;        hourlyData.time.forEachIndexed { index, timeString -&gt;&#10;            if (filteredHours.size &gt;= 24) return@forEachIndexed&#10;&#10;            if (timeString.startsWith(targetDate)) {&#10;                val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm&quot;, Locale.getDefault())&#10;                val calendar = Calendar.getInstance()&#10;&#10;                try {&#10;                    calendar.time = dateFormat.parse(timeString) ?: return@forEachIndexed&#10;&#10;                    val hourFormat = SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault())&#10;                    val displayTime = hourFormat.format(calendar.time)&#10;&#10;                    val temp = hourlyData.temperature[index].toInt()&#10;                    val weatherCode = hourlyData.weatherCode[index]&#10;                    val humidity = hourlyData.humidity[index]&#10;&#10;                    filteredHours.add(&#10;                        HourlyForecastItem(&#10;                            time = displayTime,&#10;                            temperature = &quot;$temp째&quot;,&#10;                            weatherIcon = WeatherCodeMapper.getWeatherIcon(weatherCode),&#10;                            humidity = humidity&#10;                        )&#10;                    )&#10;                } catch (e: Exception) {&#10;                    // Skip this hour if parsing fails&#10;                }&#10;            }&#10;        }&#10;&#10;        return filteredHours&#10;    }&#10;&#10;    private fun getCurrentDate(): String {&#10;        val calendar = Calendar.getInstance()&#10;        val dateFormat = SimpleDateFormat(&quot;EEEE, dd MMM&quot;, Locale.getDefault())&#10;        return dateFormat.format(calendar.time)&#10;    }&#10;&#10;    private fun getAirQualityColor(uvIndex: Int): String {&#10;        return when {&#10;            uvIndex &lt;= 2 -&gt; &quot;#2dbe8d&quot; // Green - Low&#10;            uvIndex &lt;= 5 -&gt; &quot;#f9cf5f&quot; // Yellow - Moderate&#10;            uvIndex &lt;= 7 -&gt; &quot;#ff9966&quot; // Orange - High&#10;            else -&gt; &quot;#ff7676&quot; // Red - Very High&#10;        }&#10;    }&#10;&#10;    fun selectDay(dayIndex: Int) {&#10;        val weatherData = _uiState.value.weatherData ?: return&#10;&#10;        // Update selected day index&#10;        _uiState.value = _uiState.value.copy(selectedDayIndex = dayIndex)&#10;&#10;        // Update forecast items with new selection&#10;        val forecastItems = mapToForecastItems(weatherData)&#10;&#10;        // Update current weather display based on selected day&#10;        val dailyData = weatherData.daily&#10;        if (dayIndex &lt; dailyData.time.size) {&#10;            val selectedWeatherCode = dailyData.weatherCode[dayIndex]&#10;            val selectedMaxTemp = dailyData.temperatureMax[dayIndex].toInt()&#10;            val selectedMinTemp = dailyData.temperatureMin[dayIndex].toInt()&#10;            val selectedDate = dailyData.time[dayIndex]&#10;&#10;            // Format the selected date&#10;            val calendar = Calendar.getInstance()&#10;            val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;            calendar.time = dateFormat.parse(selectedDate) ?: Date()&#10;            val formattedDate = SimpleDateFormat(&quot;EEEE, dd MMM&quot;, Locale.getDefault()).format(calendar.time)&#10;&#10;            // Update hourly forecast for selected day&#10;            val hourlyForecastItems = mapToHourlyForecastItems(weatherData, dayIndex)&#10;&#10;            // Update air quality for selected day&#10;            val airQualityItems = mapToAirQualityItems(weatherData, dayIndex)&#10;&#10;            // Generate weather tips for selected day&#10;            val weatherTips = WeatherCodeMapper.getWeatherTips(&#10;                context = context,&#10;                weatherCode = selectedWeatherCode,&#10;                temperature = selectedMaxTemp,&#10;                uvIndex = dailyData.uvIndexMax.getOrNull(dayIndex)?.toInt() ?: 0,&#10;                humidity = weatherData.current.humidity&#10;            )&#10;&#10;            _uiState.value = _uiState.value.copy(&#10;                forecastItems = forecastItems,&#10;                hourlyForecastItems = hourlyForecastItems,&#10;                airQualityItems = airQualityItems,&#10;                weatherTips = weatherTips,&#10;                currentTemperature = selectedMaxTemp.toString(),&#10;                currentDescription = WeatherCodeMapper.getWeatherDescription(context, selectedWeatherCode),&#10;                currentDate = formattedDate,&#10;                feelsLike = &quot;High $selectedMaxTemp째  Low $selectedMinTemp째&quot;,&#10;                currentWeatherIcon = WeatherCodeMapper.getWeatherIcon(selectedWeatherCode),&#10;                currentWeatherVideo = WeatherCodeMapper.getWeatherVideo(selectedWeatherCode)&#10;            )&#10;        }&#10;    }&#10;&#10;    fun addLocation(location: Location) {&#10;        val updatedLocations = _uiState.value.savedLocations + location&#10;        _uiState.value = _uiState.value.copy(savedLocations = updatedLocations)&#10;    }&#10;&#10;    fun removeLocation(location: Location) {&#10;        val updatedLocations = _uiState.value.savedLocations.filter { it != location }&#10;        _uiState.value = _uiState.value.copy(savedLocations = updatedLocations)&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package androidlead.weatherappui.viewmodel&#10;&#10;import android.content.Context&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import androidlead.weatherappui.R&#10;import androidlead.weatherappui.data.model.Location&#10;import androidlead.weatherappui.data.model.SavedLocation&#10;import androidlead.weatherappui.data.model.WeatherResponse&#10;import androidlead.weatherappui.data.repository.LocationRepository&#10;import androidlead.weatherappui.data.repository.WeatherRepository&#10;import androidlead.weatherappui.service.LocationService&#10;import androidlead.weatherappui.ui.screen.util.AirQualityItem&#10;import androidlead.weatherappui.ui.screen.util.ForecastItem&#10;import androidlead.weatherappui.ui.screen.util.HourlyForecastItem&#10;import androidlead.weatherappui.ui.screen.util.WeatherTipItem&#10;import androidlead.weatherappui.util.WeatherCodeMapper&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.Calendar&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;data class WeatherUiState(&#10;    val isLoading: Boolean = false,&#10;    val currentLocation: Location? = null,&#10;    val savedLocations: List&lt;Location&gt; = emptyList(),&#10;    val weatherData: WeatherResponse? = null,&#10;    val forecastItems: List&lt;ForecastItem&gt; = emptyList(),&#10;    val hourlyForecastItems: List&lt;HourlyForecastItem&gt; = emptyList(),&#10;    val airQualityItems: List&lt;AirQualityItem&gt; = emptyList(),&#10;    val weatherTips: List&lt;WeatherTipItem&gt; = emptyList(),&#10;    val currentTemperature: String = &quot;21&quot;,&#10;    val currentDescription: String = &quot;Rain showers&quot;,&#10;    val currentDate: String = &quot;Monday, 12 Feb&quot;,&#10;    val feelsLike: String = &quot;Feels like 26째&quot;,&#10;    val currentWeatherIcon: Int = R.drawable.img_sub_rain,&#10;    val currentWeatherVideo: Int = R.raw.video_rain,&#10;    val error: String? = null,&#10;    val hasLocationPermission: Boolean = false,&#10;    val selectedDayIndex: Int = 0&#10;)&#10;&#10;class WeatherViewModel(private val context: Context) : ViewModel() {&#10;&#10;    private val repository = WeatherRepository()&#10;    private val locationRepository = LocationRepository(context)&#10;    private val locationService = LocationService(context)&#10;&#10;    private val _uiState = MutableStateFlow(WeatherUiState())&#10;    val uiState: StateFlow&lt;WeatherUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Default locations&#10;    private val defaultLocations = listOf(&#10;        Location(&quot;Rome&quot;, 41.9028, 12.4964),&#10;        Location(&quot;New York&quot;, 40.7128, -74.0060),&#10;        Location(&quot;Tokyo&quot;, 35.6762, 139.6503),&#10;        Location(&quot;London&quot;, 51.5074, -0.1278),&#10;        Location(&quot;Paris&quot;, 48.8566, 2.3522)&#10;    )&#10;&#10;    init {&#10;        _uiState.value = _uiState.value.copy(&#10;            savedLocations = defaultLocations,&#10;            hasLocationPermission = locationService.hasLocationPermission()&#10;        )&#10;        // Load from cache first, then fetch if needed&#10;        loadFromCacheOrFetch()&#10;    }&#10;&#10;    private fun loadFromCacheOrFetch() {&#10;        viewModelScope.launch {&#10;            // Try to load selected location from cache&#10;            val cachedLocation = locationRepository.getSelectedLocation().first()&#10;            val savedLocations = locationRepository.getSavedLocations().first()&#10;&#10;            // Check if this is first launch (no saved locations and no cached selected location)&#10;            if (savedLocations.isEmpty() &amp;&amp; cachedLocation == null &amp;&amp; locationService.hasLocationPermission()) {&#10;                // First launch with permission - automatically load GPS location&#10;                loadCurrentLocationWeatherAndSave()&#10;            } else if (cachedLocation != null &amp;&amp; locationRepository.isLocationCacheValid(cachedLocation)) {&#10;                // Use cached data (loadless)&#10;                loadFromCachedLocation(cachedLocation)&#10;            } else if (cachedLocation != null) {&#10;                // Show cached data first, then refresh&#10;                loadFromCachedLocation(cachedLocation)&#10;                loadWeather(cachedLocation.latitude, cachedLocation.longitude, cachedLocation.name)&#10;            } else if (savedLocations.isNotEmpty()) {&#10;                // Load first saved location if no selected location&#10;                val firstLocation = savedLocations.first()&#10;                loadWeather(firstLocation.latitude, firstLocation.longitude, firstLocation.name)&#10;            } else {&#10;                // No cache, no saved locations - load default location&#10;                loadWeatherForLocation(defaultLocations[0])&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun loadCurrentLocationWeatherAndSave() {&#10;        _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;        val locationCoords = locationService.getCurrentLocation()&#10;        if (locationCoords != null) {&#10;            val (lat, lon) = locationCoords&#10;            val cityName = locationService.getCityName(lat, lon)&#10;            val currentLocation = Location(cityName, lat, lon, isCurrentLocation = true)&#10;&#10;            _uiState.value = _uiState.value.copy(currentLocation = currentLocation)&#10;            &#10;            // Load weather and automatically save to saved locations&#10;            loadWeatherAndSaveAsCurrentLocation(lat, lon, cityName)&#10;        } else {&#10;            // If GPS fails, fall back to default location&#10;            _uiState.value = _uiState.value.copy(isLoading = false)&#10;            loadWeatherForLocation(defaultLocations[0])&#10;        }&#10;    }&#10;&#10;    private fun loadFromCachedLocation(location: SavedLocation) {&#10;        val calendar = Calendar.getInstance()&#10;        val formattedDate = SimpleDateFormat(&quot;EEEE, dd MMM&quot;, Locale.getDefault()).format(calendar.time)&#10;&#10;        _uiState.value = _uiState.value.copy(&#10;            isLoading = false,&#10;            currentLocation = Location(location.name, location.latitude, location.longitude),&#10;            currentTemperature = location.temperature.toInt().toString(),&#10;            currentDescription = location.weatherCondition,&#10;            currentDate = formattedDate,&#10;            feelsLike = context.getString(R.string.feels_like) + &quot; ${location.apparentTemperature.toInt()}째&quot;,&#10;            currentWeatherIcon = WeatherCodeMapper.getWeatherIcon(location.weatherCode),&#10;            currentWeatherVideo = WeatherCodeMapper.getWeatherVideo(location.weatherCode)&#10;        )&#10;    }&#10;&#10;    fun checkAndRequestLocation() {&#10;        if (locationService.hasLocationPermission()) {&#10;            _uiState.value = _uiState.value.copy(hasLocationPermission = true)&#10;            loadCurrentLocationWeather()&#10;        } else {&#10;            _uiState.value = _uiState.value.copy(hasLocationPermission = false)&#10;        }&#10;    }&#10;&#10;    fun loadCurrentLocationWeather() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;            val locationCoords = locationService.getCurrentLocation()&#10;            if (locationCoords != null) {&#10;                val (lat, lon) = locationCoords&#10;                val cityName = locationService.getCityName(lat, lon)&#10;                val currentLocation = Location(cityName, lat, lon, isCurrentLocation = true)&#10;&#10;                _uiState.value = _uiState.value.copy(currentLocation = currentLocation)&#10;                loadWeather(lat, lon, cityName)&#10;            } else {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    error = &quot;Failed to get current location&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadWeatherForLocation(location: Location) {&#10;        loadWeather(location.latitude, location.longitude, location.name)&#10;    }&#10;&#10;    fun fetchWeatherByCoordinates(latitude: Double, longitude: Double, locationName: String) {&#10;        loadWeather(latitude, longitude, locationName)&#10;    }&#10;&#10;    private fun loadWeather(latitude: Double, longitude: Double, locationName: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;            val result = repository.getWeather(latitude, longitude)&#10;&#10;            result.onSuccess { weatherResponse -&gt;&#10;                val forecastItems = mapToForecastItems(weatherResponse)&#10;                val airQualityItems = mapToAirQualityItems(weatherResponse)&#10;                val hourlyForecastItems = mapToHourlyForecastItems(weatherResponse)&#10;&#10;                // Get current date formatted&#10;                val calendar = Calendar.getInstance()&#10;                val formattedDate = SimpleDateFormat(&quot;EEEE, dd MMM&quot;, Locale.getDefault()).format(calendar.time)&#10;&#10;                // Generate weather tips&#10;                val weatherTips = WeatherCodeMapper.getWeatherTips(&#10;                    context = context,&#10;                    weatherCode = weatherResponse.current.weatherCode,&#10;                    temperature = weatherResponse.current.temperature.toInt(),&#10;                    uvIndex = weatherResponse.daily.uvIndexMax.firstOrNull()?.toInt() ?: 0,&#10;                    humidity = weatherResponse.current.humidity&#10;                )&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    weatherData = weatherResponse,&#10;                    forecastItems = forecastItems,&#10;                    hourlyForecastItems = hourlyForecastItems,&#10;                    airQualityItems = airQualityItems,&#10;                    weatherTips = weatherTips,&#10;                    currentTemperature = weatherResponse.current.temperature.toInt().toString(),&#10;                    currentDescription = WeatherCodeMapper.getWeatherDescription(context, weatherResponse.current.weatherCode),&#10;                    currentDate = formattedDate,&#10;                    feelsLike = context.getString(R.string.feels_like) + &quot; ${weatherResponse.current.apparentTemperature.toInt()}째&quot;,&#10;                    currentWeatherIcon = WeatherCodeMapper.getWeatherIcon(weatherResponse.current.weatherCode),&#10;                    currentWeatherVideo = WeatherCodeMapper.getWeatherVideo(weatherResponse.current.weatherCode),&#10;                    currentLocation = _uiState.value.currentLocation?.copy(name = locationName)&#10;                        ?: Location(locationName, latitude, longitude)&#10;                )&#10;&#10;                // Save to cache for loadless experience next time&#10;                val cachedLocation = SavedLocation(&#10;                    id = &quot;selected_location&quot;,&#10;                    name = locationName,&#10;                    latitude = latitude,&#10;                    longitude = longitude,&#10;                    temperature = weatherResponse.current.temperature,&#10;                    weatherCondition = WeatherCodeMapper.getWeatherDescription(context, weatherResponse.current.weatherCode),&#10;                    weatherIcon = WeatherCodeMapper.getWeatherIcon(weatherResponse.current.weatherCode).toString(),&#10;                    humidity = weatherResponse.current.humidity,&#10;                    windSpeed = weatherResponse.current.windSpeed,&#10;                    apparentTemperature = weatherResponse.current.apparentTemperature,&#10;                    weatherCode = weatherResponse.current.weatherCode,&#10;                    lastUpdated = System.currentTimeMillis()&#10;                )&#10;                locationRepository.selectLocation(cachedLocation)&#10;            }.onFailure { exception -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    error = exception.message ?: &quot;Failed to load weather data&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadWeatherAndSaveAsCurrentLocation(latitude: Double, longitude: Double, locationName: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;            val result = repository.getWeather(latitude, longitude)&#10;&#10;            result.onSuccess { weatherResponse -&gt;&#10;                val forecastItems = mapToForecastItems(weatherResponse)&#10;                val airQualityItems = mapToAirQualityItems(weatherResponse)&#10;                val hourlyForecastItems = mapToHourlyForecastItems(weatherResponse)&#10;&#10;                // Get current date formatted&#10;                val calendar = Calendar.getInstance()&#10;                val formattedDate = SimpleDateFormat(&quot;EEEE, dd MMM&quot;, Locale.getDefault()).format(calendar.time)&#10;&#10;                // Generate weather tips&#10;                val weatherTips = WeatherCodeMapper.getWeatherTips(&#10;                    context = context,&#10;                    weatherCode = weatherResponse.current.weatherCode,&#10;                    temperature = weatherResponse.current.temperature.toInt(),&#10;                    uvIndex = weatherResponse.daily.uvIndexMax.firstOrNull()?.toInt() ?: 0,&#10;                    humidity = weatherResponse.current.humidity&#10;                )&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    weatherData = weatherResponse,&#10;                    forecastItems = forecastItems,&#10;                    hourlyForecastItems = hourlyForecastItems,&#10;                    airQualityItems = airQualityItems,&#10;                    weatherTips = weatherTips,&#10;                    currentTemperature = weatherResponse.current.temperature.toInt().toString(),&#10;                    currentDescription = WeatherCodeMapper.getWeatherDescription(context, weatherResponse.current.weatherCode),&#10;                    currentDate = formattedDate,&#10;                    feelsLike = context.getString(R.string.feels_like) + &quot; ${weatherResponse.current.apparentTemperature.toInt()}째&quot;,&#10;                    currentWeatherIcon = WeatherCodeMapper.getWeatherIcon(weatherResponse.current.weatherCode),&#10;                    currentWeatherVideo = WeatherCodeMapper.getWeatherVideo(weatherResponse.current.weatherCode),&#10;                    currentLocation = _uiState.value.currentLocation?.copy(name = locationName)&#10;                        ?: Location(locationName, latitude, longitude)&#10;                )&#10;&#10;                // Save to both selected location cache AND saved locations with isCurrentLocation flag&#10;                val currentLocationData = SavedLocation(&#10;                    id = &quot;current_location&quot;,&#10;                    name = locationName,&#10;                    country = &quot;My Location&quot;,&#10;                    latitude = latitude,&#10;                    longitude = longitude,&#10;                    temperature = weatherResponse.current.temperature,&#10;                    weatherCondition = WeatherCodeMapper.getWeatherDescription(context, weatherResponse.current.weatherCode),&#10;                    weatherIcon = WeatherCodeMapper.getWeatherIcon(weatherResponse.current.weatherCode).toString(),&#10;                    humidity = weatherResponse.current.humidity,&#10;                    windSpeed = weatherResponse.current.windSpeed,&#10;                    apparentTemperature = weatherResponse.current.apparentTemperature,&#10;                    weatherCode = weatherResponse.current.weatherCode,&#10;                    isCurrentLocation = true,&#10;                    lastUpdated = System.currentTimeMillis()&#10;                )&#10;                &#10;                // Save as selected location&#10;                locationRepository.selectLocation(currentLocationData)&#10;                &#10;                // Also save to saved locations list&#10;                locationRepository.saveLocation(currentLocationData)&#10;                &#10;            }.onFailure { exception -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    error = exception.message ?: &quot;Failed to load weather data&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapToForecastItems(weatherResponse: WeatherResponse): List&lt;ForecastItem&gt; {&#10;        val dailyData = weatherResponse.daily&#10;        val selectedIndex = _uiState.value.selectedDayIndex&#10;        return dailyData.time.mapIndexed { index, date -&gt;&#10;            val calendar = Calendar.getInstance()&#10;            val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;            calendar.time = dateFormat.parse(date) ?: Date()&#10;&#10;            val dayOfWeek = SimpleDateFormat(&quot;EEE&quot;, Locale.getDefault()).format(calendar.time)&#10;            val dateStr = SimpleDateFormat(&quot;dd MMM&quot;, Locale.getDefault()).format(calendar.time)&#10;&#10;            val weatherCode = dailyData.weatherCode[index]&#10;            val maxTemp = dailyData.temperatureMax[index].toInt()&#10;            val uvIndex = dailyData.uvIndexMax.getOrNull(index)?.toInt() ?: 0&#10;&#10;            ForecastItem(&#10;                image = WeatherCodeMapper.getWeatherIcon(weatherCode),&#10;                dayOfWeek = dayOfWeek,&#10;                date = dateStr,&#10;                temperature = &quot;$maxTemp째&quot;,&#10;                airQuality = uvIndex.toString(),&#10;                airQualityIndicatorColorHex = getAirQualityColor(uvIndex),&#10;                isSelected = index == selectedIndex&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun mapToAirQualityItems(weatherResponse: WeatherResponse, dayIndex: Int = 0): List&lt;AirQualityItem&gt; {&#10;        val dailyData = weatherResponse.daily&#10;        val hourlyData = weatherResponse.hourly&#10;        val current = weatherResponse.current&#10;&#10;        // Get data for selected day&#10;        val targetDate = if (dayIndex &lt; dailyData.time.size) {&#10;            dailyData.time[dayIndex]&#10;        } else {&#10;            dailyData.time[0]&#10;        }&#10;&#10;        // Calculate average temperature and humidity from hourly data for the selected day&#10;        var avgTemp = 0.0&#10;        var avgHumidity = 0&#10;        var count = 0&#10;&#10;        hourlyData.time.forEachIndexed { index, timeString -&gt;&#10;            if (timeString.startsWith(targetDate)) {&#10;                avgTemp += hourlyData.temperature[index]&#10;                avgHumidity += hourlyData.humidity[index]&#10;                count++&#10;            }&#10;        }&#10;&#10;        if (count &gt; 0) {&#10;            avgTemp /= count&#10;            avgHumidity /= count&#10;        } else {&#10;            // Fallback to using min/max temp average&#10;            avgTemp = (dailyData.temperatureMax[dayIndex] + dailyData.temperatureMin[dayIndex]) / 2&#10;            avgHumidity = current.humidity&#10;        }&#10;&#10;        // Get UV Index for the selected day&#10;        val uvIndex = dailyData.uvIndexMax.getOrNull(dayIndex)?.toInt() ?: 0&#10;&#10;        return listOf(&#10;            AirQualityItem(&#10;                title = context.getString(R.string.real_feel),&#10;                value = &quot;${avgTemp.toInt()}째&quot;,&#10;                icon = R.drawable.ic_real_feel&#10;            ),&#10;            AirQualityItem(&#10;                title = context.getString(R.string.wind),&#10;                value = &quot;${current.windSpeed.toInt()}${context.getString(R.string.kmh)}&quot;,&#10;                icon = R.drawable.ic_wind_qality&#10;            ),&#10;            AirQualityItem(&#10;                title = context.getString(R.string.humidity),&#10;                value = &quot;$avgHumidity${context.getString(R.string.percent)}&quot;,&#10;                icon = R.drawable.ic_so2&#10;            ),&#10;            AirQualityItem(&#10;                title = context.getString(R.string.rain),&#10;                value = &quot;0${context.getString(R.string.percent)}&quot;,&#10;                icon = R.drawable.ic_rain_chance&#10;            ),&#10;            AirQualityItem(&#10;                title = context.getString(R.string.uv_index),&#10;                value = uvIndex.toString(),&#10;                icon = R.drawable.ic_uv_index&#10;            ),&#10;            AirQualityItem(&#10;                title = context.getString(R.string.wind_dir),&#10;                value = &quot;${current.windDirection}째&quot;,&#10;                icon = R.drawable.ic_o3&#10;            )&#10;        )&#10;    }&#10;&#10;    private fun mapToHourlyForecastItems(weatherResponse: WeatherResponse, dayIndex: Int = 0): List&lt;HourlyForecastItem&gt; {&#10;        val hourlyData = weatherResponse.hourly&#10;        val dailyData = weatherResponse.daily&#10;&#10;        // Get the target date&#10;        val targetDate = if (dayIndex &lt; dailyData.time.size) {&#10;            dailyData.time[dayIndex]&#10;        } else {&#10;            dailyData.time[0]&#10;        }&#10;&#10;        // Filter hourly data for the selected day and get up to 24 hours&#10;        val filteredHours = mutableListOf&lt;HourlyForecastItem&gt;()&#10;&#10;        hourlyData.time.forEachIndexed { index, timeString -&gt;&#10;            if (filteredHours.size &gt;= 24) return@forEachIndexed&#10;&#10;            if (timeString.startsWith(targetDate)) {&#10;                val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm&quot;, Locale.getDefault())&#10;                val calendar = Calendar.getInstance()&#10;&#10;                try {&#10;                    calendar.time = dateFormat.parse(timeString) ?: return@forEachIndexed&#10;&#10;                    val hourFormat = SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault())&#10;                    val displayTime = hourFormat.format(calendar.time)&#10;&#10;                    val temp = hourlyData.temperature[index].toInt()&#10;                    val weatherCode = hourlyData.weatherCode[index]&#10;                    val humidity = hourlyData.humidity[index]&#10;&#10;                    filteredHours.add(&#10;                        HourlyForecastItem(&#10;                            time = displayTime,&#10;                            temperature = &quot;$temp째&quot;,&#10;                            weatherIcon = WeatherCodeMapper.getWeatherIcon(weatherCode),&#10;                            humidity = humidity&#10;                        )&#10;                    )&#10;                } catch (e: Exception) {&#10;                    // Skip this hour if parsing fails&#10;                }&#10;            }&#10;        }&#10;&#10;        return filteredHours&#10;    }&#10;&#10;    private fun getCurrentDate(): String {&#10;        val calendar = Calendar.getInstance()&#10;        val dateFormat = SimpleDateFormat(&quot;EEEE, dd MMM&quot;, Locale.getDefault())&#10;        return dateFormat.format(calendar.time)&#10;    }&#10;&#10;    private fun getAirQualityColor(uvIndex: Int): String {&#10;        return when {&#10;            uvIndex &lt;= 2 -&gt; &quot;#2dbe8d&quot; // Green - Low&#10;            uvIndex &lt;= 5 -&gt; &quot;#f9cf5f&quot; // Yellow - Moderate&#10;            uvIndex &lt;= 7 -&gt; &quot;#ff9966&quot; // Orange - High&#10;            else -&gt; &quot;#ff7676&quot; // Red - Very High&#10;        }&#10;    }&#10;&#10;    fun selectDay(dayIndex: Int) {&#10;        val weatherData = _uiState.value.weatherData ?: return&#10;&#10;        // Update selected day index&#10;        _uiState.value = _uiState.value.copy(selectedDayIndex = dayIndex)&#10;&#10;        // Update forecast items with new selection&#10;        val forecastItems = mapToForecastItems(weatherData)&#10;&#10;        // Update current weather display based on selected day&#10;        val dailyData = weatherData.daily&#10;        if (dayIndex &lt; dailyData.time.size) {&#10;            val selectedWeatherCode = dailyData.weatherCode[dayIndex]&#10;            val selectedMaxTemp = dailyData.temperatureMax[dayIndex].toInt()&#10;            val selectedMinTemp = dailyData.temperatureMin[dayIndex].toInt()&#10;            val selectedDate = dailyData.time[dayIndex]&#10;&#10;            // Format the selected date&#10;            val calendar = Calendar.getInstance()&#10;            val dateFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;            calendar.time = dateFormat.parse(selectedDate) ?: Date()&#10;            val formattedDate = SimpleDateFormat(&quot;EEEE, dd MMM&quot;, Locale.getDefault()).format(calendar.time)&#10;&#10;            // Update hourly forecast for selected day&#10;            val hourlyForecastItems = mapToHourlyForecastItems(weatherData, dayIndex)&#10;&#10;            // Update air quality for selected day&#10;            val airQualityItems = mapToAirQualityItems(weatherData, dayIndex)&#10;&#10;            // Generate weather tips for selected day&#10;            val weatherTips = WeatherCodeMapper.getWeatherTips(&#10;                context = context,&#10;                weatherCode = selectedWeatherCode,&#10;                temperature = selectedMaxTemp,&#10;                uvIndex = dailyData.uvIndexMax.getOrNull(dayIndex)?.toInt() ?: 0,&#10;                humidity = weatherData.current.humidity&#10;            )&#10;&#10;            _uiState.value = _uiState.value.copy(&#10;                forecastItems = forecastItems,&#10;                hourlyForecastItems = hourlyForecastItems,&#10;                airQualityItems = airQualityItems,&#10;                weatherTips = weatherTips,&#10;                currentTemperature = selectedMaxTemp.toString(),&#10;                currentDescription = WeatherCodeMapper.getWeatherDescription(context, selectedWeatherCode),&#10;                currentDate = formattedDate,&#10;                feelsLike = &quot;High $selectedMaxTemp째  Low $selectedMinTemp째&quot;,&#10;                currentWeatherIcon = WeatherCodeMapper.getWeatherIcon(selectedWeatherCode),&#10;                currentWeatherVideo = WeatherCodeMapper.getWeatherVideo(selectedWeatherCode)&#10;            )&#10;        }&#10;    }&#10;&#10;    fun addLocation(location: Location) {&#10;        val updatedLocations = _uiState.value.savedLocations + location&#10;        _uiState.value = _uiState.value.copy(savedLocations = updatedLocations)&#10;    }&#10;&#10;    fun removeLocation(location: Location) {&#10;        val updatedLocations = _uiState.value.savedLocations.filter { it != location }&#10;        _uiState.value = _uiState.value.copy(savedLocations = updatedLocations)&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>